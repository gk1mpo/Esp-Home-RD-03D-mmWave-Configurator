/*////////////////////////////////////////////////////////////////////////////////////////////
â€œCoordinate model. The radar is directional. We place the sensor origin on a chosen canvas 
edge and render only the forward field of view as a semicircular sector spanning âˆ’90Â° to +90Â° 
relative to the sensorâ€™s facing direction. The sector grows outward from the origin into the 
canvas; nothing is drawn â€˜behindâ€™ the sensor. Distances are rendered radially (meters â†’ pixels), 
angles are measured clockwise from â€˜forwardâ€™, and an angle offset equal to the installation 
direction is applied so the visual matches the real mounting. A dashed radial grid every 1 m 
and a bolder ring every 5 m help with calibration and testing.â€*/
/////////////////////////////////////////////////////////////////////////////////////////////




import { LovelaceBridgeInterface } from '/local/everything-presence-mmwave-configurator/lovelace-bridge-interface.js';
import { RadarCanvas } from '/local/everything-presence-mmwave-configurator/radar-canvas.js';
class EPZoneConfiguratorCard extends HTMLElement {
  SCALE = 10; // 1 m = 40 px
  

  constructor() {
    super();
    this._dragging = null;   // { zoneNum, corner }
    this._zonesCache = {};   // last drawn zones for editing
    this._touchMarker = null;
    this._tileStates = this._tileStates || {};
    this._editing = false;  // currently dragging
    this._editMode = false; // unsaved local changes
  }
  set hass(hass) {
    this._hass = hass;
    // Pass HA state down to radar canvas
    // Pass HA state down to radar canvas
    if (this.radarCanvas) {
      this.radarCanvas._hass = hass;
      this.radarCanvas._selectedDevice = this._selectedDevice;
    }

    // Trigger draw only when both are ready
    if (this.isConnected && this._selectedDevice && this.radarCanvas) {
      this.radarCanvas.draw();
    }
    
    // 1ï¸âƒ£ Create the bridge first
    if (!this.bridge && this._hass) {
      console.info('[Card] Initialising bridgeâ€¦');
      this.bridge = new LovelaceBridgeInterface(this._hass);
    }

    // 2ï¸âƒ£ Initialise the card UI only once â€” defer until bridge is ready
    if (!this._initialized && this.bridge && this._hass) {
      // Defer one microtask so the shadow DOM exists when initialize() runs
      Promise.resolve().then(() => this.initialize());
    }

    // 3ï¸âƒ£ Keep bridge reference current
    if (this.bridge) this.bridge.hass = this._hass;

    // 4ï¸âƒ£ Update HA connection state label
    if (this._hass && !this._haReady) {
      const status = this.shadowRoot?.querySelector('#status-text');
      if (status) status.textContent = 'Connected to Home Assistant âœ…';
      this._haReady = true;
    }

    // 5ï¸âƒ£ Regular updates (only if bridge ready)
    if (this.bridge) this.onHassUpdate();

    // 6ï¸âƒ£ Attach canvas event listeners once (only after DOM is ready)
    if (!this._canvasListenersAttached) {
      const attachCanvasListeners = () => {
        const canvas = this.shadowRoot?.querySelector('#visualizationCanvas');
        if (!canvas) return; // nothing to attach yet

        // ðŸ–±ï¸ Mouse support
        canvas.addEventListener('mousedown', (e) => this.onCanvasDown(e));
        canvas.addEventListener('mousemove', (e) => this.onCanvasMove(e));
        canvas.addEventListener('mouseup',   (e) => this.onCanvasUp(e));

        // ðŸ–ï¸ Touch support
        canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const t = e.touches[0];
          this.onCanvasDown({
            clientX: t.clientX,
            clientY: t.clientY,
            target: canvas,
            touches: e.touches
          });
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const t = e.touches[0];
          this.onCanvasMove({
            clientX: t.clientX,
            clientY: t.clientY,
            target: canvas,
            touches: e.touches
          });
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
          e.preventDefault();
          this.onCanvasUp(e);
        });
        canvas.addEventListener('mouseleave', (e) => this.onCanvasUp(e));

        this._canvasListenersAttached = true;
        console.info('[Card] Canvas event listeners attached âœ…');
      };

      // Delay attaching listeners until after initialize() has built the shadow DOM
      Promise.resolve().then(attachCanvasListeners);
    }

  }

onHassUpdate() {
  if (!this._selectedDevice || !this._hass || !this.radarCanvas)
    return;
  if (this._editing || this._editMode) {
    console.info('[Card] Skipping HA update â€” local edit in progress.');
    return;
  }
  // ðŸ§­ Skip redundant updates
  if (this._lastUpdate && Date.now() - this._lastUpdate < 200) return;
    this._lastUpdate = Date.now();
    const dev = this._selectedDevice;

  // 1ï¸âƒ£ Direction & distance
  const dirEntity =
    this._hass.states[`number.${dev}_installation_angle`] ||
    this._hass.states[`sensor.${dev}_installation_angle`] ||
    this._hass.states[`number.${dev}_direction`];

  const distEntity =
    this._hass.states[`number.${dev}_distance`] ||
    this._hass.states[`sensor.${dev}_max_distance`];

  this._directionDeg = Number(dirEntity?.state || 0);
  this._maxMeters = Math.max(1, Number(distEntity?.state || 6));

  //console.log(`[Card] Direction=${this._directionDeg}Â°, MaxDist=${this._maxMeters}m`);

  // 2ï¸âƒ£ Zones
  this._zones = {};
  for (let i = 1; i <= 4; i++) {
    const en = this._hass.states[`switch.${dev}_zone_${i}_enable`];
    const oc = this._hass.states[`binary_sensor.${dev}_zone_${i}_occupied`];
    const x1 = Number(this._hass.states[`number.${dev}_zone_${i}_x1`]?.state || 0);
    const y1 = Number(this._hass.states[`number.${dev}_zone_${i}_y1`]?.state || 0);
    const x2 = Number(this._hass.states[`number.${dev}_zone_${i}_x2`]?.state || x1 + 1);
    const y2 = Number(this._hass.states[`number.${dev}_zone_${i}_y2`]?.state || y1 + 1);

    this._zones[i] = {
      id: i,
      enabled: en?.state === 'on',
      occupied: oc?.state === 'on',
      start: { x: x1, y: y1 },
      end: { x: x2, y: y2 },
      fill: oc?.state === 'on'
        ? 'rgba(255, 0, 0, 0.25)'
        : 'rgba(13,110,253,0.2)'
    };
  }

  // 3ï¸âƒ£ Targets
  this._targets = {};
  for (let i = 1; i <= 4; i++) {
    const tx = Number(this._hass.states[`sensor.${dev}_target_${i}_x`]?.state || 0);
    const ty = Number(this._hass.states[`sensor.${dev}_target_${i}_y`]?.state || 0);
    this._targets[i] = { x: tx, y: ty };
  }

  // 4ï¸âƒ£ Merge optional bridge data
  if (this.bridge) {
    const bridgeZones = this.bridge.getZones(dev);
    const bridgeTargets = this.bridge.getTargets(dev);
    if (bridgeZones && Object.keys(bridgeZones).length) this._zones = bridgeZones;
    if (bridgeTargets && Object.keys(bridgeTargets).length) this._targets = bridgeTargets;
  }

  // 5ï¸âƒ£ Push config into RadarCanvas
  
    this.radarCanvas.theta = this._directionDeg * Math.PI / 180;
    this.radarCanvas.maxRange = this._maxMeters;
    
    this.radarCanvas.update(this._zones, this._targets);
  

  // 6ï¸âƒ£ Refresh sidebar UI
  this.updateSidebar?.();
}

initialize() {
  this._initialized = true;
  this.attachShadow({ mode: 'open' });

  // === Load external CSS ===
  fetch('/local/everything-presence-mmwave-configurator/styles.css')
    .then(r => r.text())
    .then(css => {
      const style = document.createElement('style');
      style.textContent = css;
      this.shadowRoot.append(style);
    });

  // === DOM structure ===
  const container = document.createElement('div');
  container.id = 'container';
  container.innerHTML = `
    <header>
      <h1>EP Zone Configurator Bridge Mobile Test v1.6</h1>
      <div class="header-controls">
        <select id="device-select"><option>Loadingâ€¦</option></select>
        <button id="import-zones">Import Zones</button>
        <button id="export-zones">Export Zones</button>
      </div>
      <div id="edit-banner" style="display:none; color:orange; font-weight:bold; margin-left:1em;">
        Unsaved zone changes â€” click Export Zones to save.
      </div>
    </header>
    <main class="main-content">
      <div class="canvas-wrapper">
        <canvas id="visualizationCanvas" width="960" height="600"></canvas>
      </div>
      <aside class="zone-sidebar">
        <h3>Zones</h3>
        <div id="zone-tiles"></div>
      </aside>
    </main>
    `;

    this.shadowRoot.append(container);

    // === Canvas setup ===
    const canvas = this.shadowRoot.querySelector('#visualizationCanvas');
    if (!canvas) {
      console.error('[Card] No canvas element found.');
      return;
    }

    // Create the RadarCanvas renderer (handles its own resizing)
    this.radarCanvas = new RadarCanvas(canvas);
    this.radarCanvas.resize(); // ensure _width/_height are set before first draw

    // Redraw automatically on resize/orientation change
    const resizeHandler = () => this.radarCanvas.resize();
    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', resizeHandler);

   
   

    // === Device selector ===

    //this.bridge = null;
    this.populateDevices();
     // === Header button actions ===
      this.shadowRoot.getElementById('import-zones')
      .addEventListener('click', () => this.loadZonesFromHA());
    this.shadowRoot.getElementById('export-zones')
      .addEventListener('click', () => this.saveZonesToHA());
    //document.getElementById('export-zones')?.addEventListener('click', () => this.saveZonesToHA());
    //document.getElementById('import-zones')?.addEventListener('click', () => this.loadZonesFromHA());

    console.info('[Card] Initialization complete âœ…');
  }



    showTouchMarker(x, y, color = 'orange') {
      this._touchMarker = { x, y, color, timestamp: Date.now() };
  }
  showUnsavedBanner() {
    const banner = this.shadowRoot.querySelector('#edit-banner');
    if (banner) banner.style.display = 'inline';
  }
  
  onCanvasDown(e) {
    if (!this._zones) return;
    this._editing = true; // ignore HA updates while dragging

    const rect = e.target.getBoundingClientRect();
    const isTouch = e.touches && e.touches.length;
    const clientX = isTouch ? e.touches[0].clientX : e.clientX;
    const clientY = isTouch ? e.touches[0].clientY : e.clientY;
    this._editing = true;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    // ðŸ’¡ Log pointer position for verification
    const world = this.radarCanvas.canvasToWorld(x, y);
    console.log('in canvas Down', { world, canvas: { x, y }, origin: this.radarCanvas.origin });

    // --- New: hit-test corners using the same worldâ†’canvas transform as drawing ---
    for (const [zoneNum, z] of Object.entries(this._zones)) {
      for (const corner of ['start', 'end']) {
        if (!z[corner]) continue;

        const c = this.radarCanvas.worldToCanvas(z[corner].x, z[corner].y);
        const dx = x - c.x;
        const dy = y - c.y;

        if (Math.hypot(dx, dy) < 15) {
          this._dragging = { zoneNum, corner };
          console.info(`[Card] Drag start Z${zoneNum} corner=${corner}`, c);
          return;
        }
      }
    }
  }

  onCanvasMove(e) {
    if (!this._dragging || !this.radarCanvas) return;

    const canvas = this.radarCanvas.canvas;
    const rect = canvas.getBoundingClientRect();

    // Handle both mouse and touch
    const isTouch = e.touches && e.touches.length;
    const clientX = isTouch ? e.touches[0].clientX : e.clientX;
    const clientY = isTouch ? e.touches[0].clientY : e.clientY;

    // Convert window â†’ canvas coordinates
    let x = clientX - rect.left;
    let y = clientY - rect.top;

    // Clamp pointer inside canvas bounds
    x = Math.max(0, Math.min(rect.width, x));
    y = Math.max(0, Math.min(rect.height, y));

    // Convert canvas â†’ world (correct for top-edge origin, rotation, and scale)
    const world = this.radarCanvas.canvasToWorld(x, y);

    const { zoneNum, corner } = this._dragging;
    const zone = this._zones[zoneNum];
    if (!zone || !zone[corner]) return;

    // === Update geometry in world space ===
    zone[corner].x = world.x;
    zone[corner].y = Math.max(0, world.y); // clamp to keep above radar origin

    // === Optional: enforce min size if both corners exist ===
    if (zone.start && zone.end) {
      const minSpan = 0.1; // meters
      const dx = Math.abs(zone.end.x - zone.start.x);
      const dy = Math.abs(zone.end.y - zone.start.y);
      if (dx < minSpan) {
        if (corner === 'start') zone.start.x = zone.end.x - minSpan;
        else zone.end.x = zone.start.x + minSpan;
      }
      if (dy < minSpan) {
        if (corner === 'start') zone.start.y = zone.end.y - minSpan;
        else zone.end.y = zone.start.y + minSpan;
      }
    }

    // === Redraw the updated world model ===
    this.radarCanvas.update(this._zones, this._targets);

    // === Optional feedback marker ===
    if (!this._lastMarker || Date.now() - this._lastMarker > 80) {
      this.showTouchMarker(x, y, 'lime');
      this._lastMarker = Date.now();
    }
  }


  onCanvasUp() {
    if (this._dragging) {
      console.info('[Card] Finished dragging', this._dragging);
      this._dragging = null;
    }
    this._touchMarker = null;  // <â€” clear the overlay marker
    
    if (this._editing) {
      console.info('[Card] Drag complete â€” keeping local zone positions.');
      this._editing = false;
      this._editMode = true; // now there are unsaved changes
      console.info('[Card] Edit mode active â€” local zones modified.');
      this.showUnsavedBanner();
    }
  }

  setConfig(config) {
    this._config = config || {};
    this.debug = !!this._config.debug;
  }
  saveZonesToHA() {
    if (!this._hass || !this._selectedDevice || !this._zones) return;

    for (const [zoneNum, z] of Object.entries(this._zones)) {
      if (!z.start || !z.end) continue;
      const prefix = `number.${this._selectedDevice}_zone_${zoneNum}`;
      const svc = (eid, value) => {
        this._hass.callService('number', 'set_value', {
          entity_id: eid,
          value: value.toFixed(3)
        });
      };
      svc(`${prefix}_x_begin`, z.start.x);
      svc(`${prefix}_x_end`, z.end.x);
      svc(`${prefix}_y_begin`, z.start.y);
      svc(`${prefix}_y_end`, z.end.y);
    }
    const banner = this.shadowRoot.querySelector('#edit-banner');
    if (banner) banner.style.display = 'none';
    this._editMode = false;
    console.info('[Card] Zones saved to HA â€” sync re-enabled.')

    console.log(`[RadarCanvas] Saved ${Object.keys(this._zones).length} zones to HA`);
  }

  loadZonesFromHA() {
    if (!this._hass || !this._selectedDevice) return;
    const zones = {};
    for (const [id, state] of Object.entries(this._hass.states)) {
      if (!id.startsWith(`number.${this._selectedDevice}_zone_`)) continue;
      const m = id.match(/zone_(\d+)_(x|y)_(begin|end)/);
      if (!m) continue;
      const [_, z, axis, edge] = m;
      zones[z] = zones[z] || { start: {}, end: {}, enabled: true };
      zones[z][edge === 'begin' ? 'start' : 'end'][axis] = parseFloat(state.state);
    }
    this._zones = zones;
    this.radarCanvas.draw();
    console.log(`[RadarCanvas] Loaded ${Object.keys(zones).length} zones from HA`);
  }
  

  


  // Update Sidebar
  updateSidebar() {
    // Match your HTML ID exactly
    const container = this.shadowRoot.querySelector('#zone-tiles');
    if (!container || !this._selectedDevice) return;

    // Prefer local zones built by _onHassUpdate()
    let zones = this._zones || {};

    // If bridge data exists and has zones, use it instead
    if (this.bridge) {
      const bridgeZones = this.bridge.getZones(this._selectedDevice);
      if (bridgeZones && Object.keys(bridgeZones).length) zones = bridgeZones;
    }

    // Pull switch states directly from HA for enable/occupy status
    const zoneSwitches = Object.entries(this._hass.states)
      .filter(([id]) => id.includes(`${this._selectedDevice}_zone_`) && id.includes('_enable'));

    container.innerHTML = '';

    zoneSwitches.forEach(([id, entity]) => {
      const zoneNumMatch = id.match(/zone_(\d+)_/);
      if (!zoneNumMatch) return;
      const zoneNum = zoneNumMatch[1];

      const enabled = entity.state === 'on';
      const occEntity = this._hass.states[`binary_sensor.${this._selectedDevice}_zone_${zoneNum}_in_zone`];
      const occupied = occEntity?.state === 'on';

      const z = zones[zoneNum] || { start: {}, end: {} };

      const tile = document.createElement('div');
      tile.className = `zone-tile ${occupied ? 'zone-occupied' : enabled ? 'zone-enabled' : 'zone-disabled'}`;
      tile.style = `
        border:1px solid #888;
        border-radius:8px;
        padding:0.5em;
        margin-bottom:0.5em;
        cursor:pointer;
        background:${enabled
          ? occupied
            ? 'rgba(25,135,84,0.3)'
            : 'rgba(13,110,253,0.1)'
          : 'rgba(200,200,200,0.2)'};
      `;
      tile.innerHTML = `
        <strong>Zone ${zoneNum}</strong><br>
        Enabled: ${enabled}<br>
        Occupied: ${occupied}<br>
        X: ${(z.start?.x ?? '?')} â†’ ${(z.end?.x ?? '?')}<br>
        Y: ${(z.start?.y ?? '?')} â†’ ${(z.end?.y ?? '?')}
      `;

      tile.onclick = () => {
        // ðŸ«§ Light haptic feedback for mobile
        if (navigator.vibrate) navigator.vibrate(20);
        this._activeZone = zoneNum;
        this.radarCanvas.highlightZone(zoneNum);  // âœ… call into canvas        
        this.shadowRoot.querySelectorAll('.zone-tile').forEach(t => t.classList.remove('active'));
        tile.classList.add('active');

        // Toggle the HA switch if context exists
        if (this._hass) {
          this._hass.callService('switch', 'toggle', { entity_id: id });
        }
      };

      // Small animation pulse on state change
      const prev = this._tileStates?.[zoneNum];
      const curr = occupied ? 'occupied' : enabled ? 'enabled' : 'disabled';
      this._tileStates = this._tileStates || {};
      this._tileStates[zoneNum] = curr;
      if (prev && prev !== curr) {
        tile.classList.add('pulse');
        setTimeout(() => tile.classList.remove('pulse'), 400);
      }

      container.append(tile);

      
    });

    
  }
  _round(x) {
    // Snap to half-pixel boundary for crisp 1px strokes
    return Math.round(x) + 0.5;
  }

  /*
  Design Concept:
  ----------------
  The radar sensor is modelled as having a forward-facing detection arc only â€” 
  it cannot detect objects behind it. To represent this visually, the sensor's 
  origin is positioned along one edge of the canvas (typically the top edge). 
  The detection arc then extends outward into the canvas, covering an angular 
  range of approximately â€“90Â° to +90Â° relative to the sensorâ€™s forward axis.

  This approach simplifies the coordinate logic: 
  the origin remains fixed at the edge, and the arc of detection always 
  projects forward in a single direction. It provides a clear visual 
  representation of how the radar perceives its environment.
  */

  
 
  populateDevices() {
    if (!this.bridge) {
      console.warn('[Card] populateDevices() called before bridge exists â€” skipping.');
      return;
    }

    const select = this.shadowRoot.querySelector('#device-select');
    const devices = this.bridge.getDevices();

    if (!devices.length) {
      select.innerHTML = '<option>No ESPHome devices found</option>';
      this._selectedDevice = null;
      return;
    }

    select.innerHTML = devices.map(d => `<option value="${d}">${d}</option>`).join('');

    if (!this._selectedDevice) {
      this._selectedDevice = devices[0];
      select.value = this._selectedDevice;
      console.info('[Card] Auto-selected device:', this._selectedDevice);
      this.onHassUpdate();   // kick off initial draw
    }

    select.onchange = (e) => {
      this._selectedDevice = e.target.value;
      console.info('[Card] Device changed to:', this._selectedDevice);
      this.onHassUpdate();
    };
  }


  getCardSize() { return 2; }
  setConfig(config) { this._config = config || {}; }
  
}

customElements.define('ep-zone-configurator-card', EPZoneConfiguratorCard);
